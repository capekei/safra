---
description: Always use Task-master for major implementations, fixes, or architectural changes
globs: **/*.{js,jsx,ts,tsx,py,java,kt,swift,json,yaml,yml}
alwaysApply: true
---

# **Task-master Integration for Major Implementations**

## **CRITICAL REQUIREMENT**

**ALWAYS use Task-master for major implementations, fixes, or architectural changes.** This ensures proper documentation, tracking, and project management.

## **When Task-master is MANDATORY**

### **üîß Major Fixes & Bug Resolutions**
- **Database connection issues** (SSL, authentication, connection strings)
- **API integration problems** (authentication, rate limiting, endpoints)
- **Deployment configuration issues** (environment variables, build errors)
- **Security vulnerabilities** (authentication, authorization, data exposure)
- **Performance bottlenecks** (database queries, API responses, frontend rendering)

### **üèóÔ∏è Architectural Changes**
- **Database migrations** (schema changes, new tables, relationships)
- **API refactoring** (endpoint restructuring, response format changes)
- **Authentication system changes** (OAuth, JWT, session management)
- **Frontend framework updates** (React version, state management, routing)
- **Build system modifications** (Vite config, webpack, deployment scripts)

### **üöÄ New Feature Implementations**
- **User authentication flows** (login, registration, password reset)
- **Data management features** (CRUD operations, file uploads, exports)
- **Real-time functionality** (WebSockets, live updates, notifications)
- **Third-party integrations** (payment systems, social logins, APIs)
- **Admin panels and dashboards**

### **üîí Security & Compliance**
- **Environment variable management** (API keys, secrets, configuration)
- **SSL/TLS configuration** (certificates, encryption, secure connections)
- **Data validation and sanitization** (input validation, SQL injection prevention)
- **Access control implementation** (role-based permissions, authorization)

## **Task-master Workflow for Major Changes**

### **1. Initial Assessment**
```bash
# Always start with Task-master analysis
mcp_taskmaster-ai_get_tasks --projectRoot /path/to/project
mcp_taskmaster-ai_next_task --projectRoot /path/to/project
```

### **2. Create or Update Tasks**
```bash
# For new major implementations
mcp_taskmaster-ai_add_task --projectRoot /path/to/project --prompt "Description of major change"

# For existing tasks that need updates
mcp_taskmaster-ai_update_task --id <taskId> --projectRoot /path/to/project --prompt "Updated implementation details"
```

### **3. Break Down Complex Tasks**
```bash
# Expand complex tasks into manageable subtasks
mcp_taskmaster-ai_expand_task --id <taskId> --projectRoot /path/to/project --research
```

### **4. Track Implementation Progress**
```bash
# Update subtasks as you work
mcp_taskmaster-ai_update_subtask --id <subtaskId> --projectRoot /path/to/project --prompt "Implementation progress and findings"

# Mark completed work
mcp_taskmaster-ai_set_task_status --id <taskId> --status done --projectRoot /path/to/project
```

## **Documentation Requirements**

### **üìù What to Document in Task-master**

1. **Problem Analysis**
   - Root cause identification
   - Error messages and symptoms
   - Environment details (development vs production)

2. **Solution Strategy**
   - Implementation approach
   - Alternative solutions considered
   - Risk assessment and mitigation

3. **Implementation Details**
   - Code changes made
   - Configuration updates
   - Environment variable changes

4. **Testing & Verification**
   - Test cases and results
   - Deployment verification steps
   - Success criteria

5. **Lessons Learned**
   - What worked and what didn't
   - Best practices discovered
   - Future recommendations

## **Examples of Proper Task-master Usage**

### **‚úÖ GOOD: Database SSL Fix**
```bash
# 1. Create task for SSL issue
mcp_taskmaster-ai_add_task --prompt "Fix PostgreSQL SSL connection issues with Neon database"

# 2. Expand into subtasks
mcp_taskmaster-ai_expand_task --id 1 --research

# 3. Update as you implement
mcp_taskmaster-ai_update_subtask --id 1.1 --prompt "Added NODE_TLS_REJECT_UNAUTHORIZED=0 to server/index.ts"

# 4. Mark complete
mcp_taskmaster-ai_set_task_status --id 1 --status done
```

### **‚ùå BAD: Direct Implementation**
```bash
# Don't just fix code without Task-master tracking
# Always document the process and reasoning
```

## **Integration with Existing Workflows**

### **üîó Combine with Research**
```bash
# Use research for up-to-date information
mcp_taskmaster-ai_research --query "Latest Neon database SSL configuration" --projectRoot /path/to/project

# Then update tasks with findings
mcp_taskmaster-ai_update_task --id <taskId> --prompt "Research findings: [details]" --research
```

### **üîó Version Control Integration**
- **Before major changes**: Create/update Task-master tasks
- **During implementation**: Update subtasks with progress
- **After completion**: Mark tasks done and document lessons learned
- **Before commits**: Ensure Task-master reflects current state

## **Quality Assurance**

### **‚úÖ Pre-Implementation Checklist**
- [ ] Task created in Task-master with clear description
- [ ] Subtasks broken down for complex implementations
- [ ] Research conducted for current best practices
- [ ] Implementation strategy documented

### **‚úÖ Post-Implementation Checklist**
- [ ] All code changes documented in Task-master
- [ ] Testing results recorded
- [ ] Deployment verification completed
- [ ] Lessons learned captured
- [ ] Task status updated to "done"

## **Enforcement**

**This rule is MANDATORY for all major implementations.** Failure to use Task-master for significant changes will result in:
- Incomplete documentation
- Lost implementation context
- Difficulty in troubleshooting future issues
- Poor project management practices

**Always prioritize Task-master integration over quick fixes.**
